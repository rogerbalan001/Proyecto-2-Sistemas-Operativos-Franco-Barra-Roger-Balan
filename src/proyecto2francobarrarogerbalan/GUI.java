/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package proyecto2francobarrarogerbalan;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import java.awt.*;
import java.awt.event.ActionEvent;

public class GUI extends javax.swing.JFrame {

    // --- VARIABLES GLOBALES ---
    private FileManager fileManager;
    private Timer simulationTimer;
    private GestorSesion gestorSesion; // Para manejar Admin/Usuario
    
    // Componentes visuales
    private JTree treeDirectorios;
    private DefaultTreeModel treeModel;
    private JPanel panelDisco;
    private JTable tablaProcesos;
    private DefaultTableModel tableModelProcesos;
    private JLabel lblEstadoDisco;
    
    // NUEVO: Componentes de Sesión
    private JLabel lblUsuario;
    private JButton btnCambiarUsuario;
    private JButton btnGuardar;
    private JButton btnCargar;
    public GUI() {

        initComponents();
    }
/**
     * Constructor personalizado que recibe el FileManager
     */
    public GUI(FileManager fileManager) {
        // 1. Inicializa lo básico de NetBeans
        initComponents();
       this.fileManager = fileManager;
        this.gestorSesion = new GestorSesion(); 
        
        // --- EL ARREGLO MÁGICO ---
        // Borramos todo lo que NetBeans haya puesto por defecto (paneles vacíos, layouts rotos)
        // Esto limpia el lienzo para que podamos pintar nuestro diseño.
        this.getContentPane().removeAll();
        
        // 2. Cargamos nuestro diseño oscuro
        iniciarComponentesDinamicos();
        
        // 3. Forzamos a la ventana a reconocer los cambios
        this.revalidate();
        this.repaint();
        
        // 4. Iniciamos el Timer de refresco
        simulationTimer = new Timer(500, (ActionEvent e) -> {
            actualizarVistas();
        });
        simulationTimer.start();
        
        // 5. Centrar ventana
        this.setLocationRelativeTo(null);
        actualizarVistas();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
private NodeDirectory getDirectorioSeleccionado() {
        DefaultMutableTreeNode nodoVisual = (DefaultMutableTreeNode) treeDirectorios.getLastSelectedPathComponent();
        
        if (nodoVisual == null) {
            return fileManager.getRoot(); // Si no hay nada, usa ROOT
        }
        
        // Recuperamos el objeto real (Node) que guardamos dentro del nodo visual
        Object objetoReal = nodoVisual.getUserObject();
        
        if (objetoReal instanceof NodeDirectory) {
            return (NodeDirectory) objetoReal;
        } else if (objetoReal instanceof NodeFile) {
            // Si seleccionas un archivo, devolvemos su carpeta padre
            return ((NodeFile) objetoReal).getParent();
        }
        
        return fileManager.getRoot();
    }

    // ---------------------------------------------------------
    // LÓGICA DE ACCIONES (BOTONES)
    // ---------------------------------------------------------

    private void accionCrearArchivo() {
        // 1. Detectar dónde guardar (Subcarpeta o Root)
        NodeDirectory carpetaDestino = getDirectorioSeleccionado();
        
        JTextField nombreField = new JTextField();
        JTextField tamField = new JTextField();
        Object[] message = {
            "Carpeta: " + carpetaDestino.getName(), // Mostramos dónde se va a guardar
            "Nombre del Archivo:", nombreField,
            "Tamaño (Bloques):", tamField
        };

        int option = JOptionPane.showConfirmDialog(this, message, "Crear Archivo", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            try {
                String nombre = nombreField.getText();
                int tam = Integer.parseInt(tamField.getText());
                
                if (tam <= 0) throw new NumberFormatException();

                // 2. Crear Objeto Lógico EN LA CARPETA SELECCIONADA
                NodeFile nuevo = new NodeFile(nombre, carpetaDestino, tam);
                carpetaDestino.addChild(nuevo); // <--- CAMBIO IMPORTANTE: Se agrega a la carpeta destino
                
                // 3. Crear Proceso y Solicitud
                proyecto2francobarrarogerbalan.Process proceso = fileManager.getProcessManager().createProcess("Crear " + nombre);
                
                IORequests request = new IORequests(proceso, TipoSolicitud.CREAR, nuevo.getPath(), tam, 0);
                request.setArchivoPendiente(nuevo);
                
                fileManager.getPlanificador().addRequest(request);
                JOptionPane.showMessageDialog(this, "Solicitud enviada.");
                actualizarVistas();

            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, "Error: Datos inválidos.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }
    
    private void accionCrearCarpeta() {
        NodeDirectory carpetaDestino = getDirectorioSeleccionado();
        String nombre = JOptionPane.showInputDialog(this, "Crear carpeta en: " + carpetaDestino.getName() + "\nNombre:");
        
        if (nombre != null && !nombre.trim().isEmpty()) {
             // Crear carpeta dentro de la seleccionada
             carpetaDestino.addChild(new NodeDirectory(nombre, carpetaDestino));
             actualizarVistas();
        }
    }

   private void accionEliminarArchivo() {
        // 1. Validar Permisos
        if (!gestorSesion.isAdmin()) {
            JOptionPane.showMessageDialog(this, "ACCESO DENEGADO: Solo el Administrador puede eliminar.", "Permisos", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        // 2. Obtener selección del árbol
        DefaultMutableTreeNode nodoVisual = (DefaultMutableTreeNode) treeDirectorios.getLastSelectedPathComponent();
        
        if (nodoVisual == null || nodoVisual.isRoot()) {
            JOptionPane.showMessageDialog(this, "Seleccione un archivo para eliminar.");
            return;
        }
        
        // 3. OBTENER EL OBJETO REAL (Sin buscar por nombre)
        Object objetoReal = nodoVisual.getUserObject();
        
        // Validamos que sea un Nodo nuestro (Archivo o Carpeta)
        if (objetoReal instanceof Node) {
            Node nodoABorrar = (Node) objetoReal;
            
            int confirm = JOptionPane.showConfirmDialog(this, "¿Seguro que desea eliminar " + nodoABorrar.getName() + "?");
            if (confirm == JOptionPane.YES_OPTION) {
                
                // Creamos el proceso y la solicitud DIRECTAMENTE con el objeto que recuperamos
                proyecto2francobarrarogerbalan.Process proceso = fileManager.getProcessManager().createProcess("Borrar " + nodoABorrar.getName());
                
                IORequests request = new IORequests(proceso, TipoSolicitud.ELIMINAR, nodoABorrar.getPath(), 0, 0);
                request.setArchivoPendiente(nodoABorrar); // ¡Aquí está la clave!
                
                fileManager.getPlanificador().addRequest(request);
                JOptionPane.showMessageDialog(this, "Solicitud de eliminación enviada.");
            }
        } else {
            // Esto pasa si seleccionas "Root" u otra cosa que no es un archivo
            JOptionPane.showMessageDialog(this, "No se puede eliminar este elemento.");
        }
    }

    private void accionCambiarUsuario() {
        if (gestorSesion.isAdmin()) {
            gestorSesion.setModoActual(ModoUsuario.USUARIO);
        } else {
            String pass = JOptionPane.showInputDialog("Contraseña de Admin (admin):");
            if ("admin".equals(pass)) {
                gestorSesion.setModoActual(ModoUsuario.ADMINISTRADOR);
            } else if (pass != null) {
                JOptionPane.showMessageDialog(this, "Contraseña incorrecta.");
            }
        }
        actualizarInfoUsuario();
    }
    
    private void accionGuardar() {
        // Asegúrate de que el nombre del archivo sea el que prefieras
        if (GestorPersistencia.guardarEstado(fileManager, "simulador.dat")) {
            JOptionPane.showMessageDialog(this, "Estado guardado correctamente.");
        }
    }

private void accionCargar() {
        FileManager cargado = GestorPersistencia.cargarEstado("simulador.dat");
        if (cargado != null) {
            this.fileManager = cargado;
            
            // Llamamos a los dos refrescos manualmente al cargar
            actualizarVistas(); 
            refrescarArbol(); // <--- AGREGAR ESTA LÍNEA
            
            JOptionPane.showMessageDialog(this, "Estado cargado exitosamente.");
        }
    }

    // ---------------------------------------------------------
    // MÉTODOS DE ACTUALIZACIÓN VISUAL
    // ---------------------------------------------------------

   public void actualizarVistas() {
        if (fileManager == null) return;
        
        // --- BORRAMOS LA PARTE DEL ÁRBOL DE AQUÍ ---
        
        // Solo actualizamos Tabla de Procesos
        tableModelProcesos.setRowCount(0);
        NodeList<proyecto2francobarrarogerbalan.Process> current = fileManager.getProcessManager().getProcessTable().getHead();
        while (current != null) {
            proyecto2francobarrarogerbalan.Process p = current.getData();
            tableModelProcesos.addRow(new Object[]{p.getPid(), p.getName(), p.getState()});
            current = current.getNext();
        }
        
        // Y el Mapa de Disco
        actualizarMapaDisco();
    }

    // 2. MÉTODO NUEVO: Solo lo llamaremos cuando realmente cambie un archivo.
    public void refrescarArbol() {
        if (fileManager == null) return;
        
        DefaultMutableTreeNode rootVisual = crearArbolVisual(fileManager.getRoot());
        treeModel.setRoot(rootVisual);
        treeModel.reload();
        
        // Expandir filas para ver todo
        for (int i = 0; i < treeDirectorios.getRowCount(); i++) {
            treeDirectorios.expandRow(i);
        }
    }
    
    private void actualizarInfoUsuario() {
        if (gestorSesion.isAdmin()) {
            lblUsuario.setText("Modo: ADMINISTRADOR");
            lblUsuario.setForeground(Color.RED);
        } else {
            lblUsuario.setText("Modo: USUARIO");
            lblUsuario.setForeground(Color.CYAN); // O el color que prefieras
        }
    }

private DefaultMutableTreeNode crearArbolVisual(Node nodoLogico) {
        // --- CAMBIO IMPORTANTE: Quitamos .getName() ---
        // Pasamos el OBJETO COMPLETO para poder recuperarlo después al borrar.
        DefaultMutableTreeNode nodoVisual = new DefaultMutableTreeNode(nodoLogico);
        
        if (nodoLogico instanceof NodeDirectory) {
            NodeDirectory dir = (NodeDirectory) nodoLogico;
            NodeList<Node> current = dir.getChildren().getHead();
            while (current != null) {
                nodoVisual.add(crearArbolVisual(current.getData()));
                current = current.getNext();
            }
        }
        return nodoVisual;
    }
    
    private void actualizarMapaDisco() {
        panelDisco.removeAll();
        Block[] bloques = fileManager.getDisco().getBlocks();
        int libres = 0;
        
        for (int i = 0; i < bloques.length; i++) {
            JPanel p = new JPanel();
            // Borde gris oscuro para que se vea la rejilla
            p.setBorder(BorderFactory.createLineBorder(new Color(60, 60, 60))); 
            
            if (bloques[i].isFree()) {
                p.setBackground(new Color(46, 204, 113)); // Verde
                libres++;
            } else {
                p.setBackground(new Color(231, 76, 60)); // Rojo
            }
            panelDisco.add(p);
        }
        lblEstadoDisco.setText("Bloques Libres: " + libres + " / " + bloques.length);
        panelDisco.revalidate();
        panelDisco.repaint();
    }

    // ---------------------------------------------------------
    // CONFIGURACIÓN VISUAL INICIAL (COLORES Y PANELES)
    // ---------------------------------------------------------
    
    // Colores de Alto Contraste
private final Color COLOR_FONDO = Color.BLACK;
    private final Color COLOR_TEXTO = Color.WHITE;
    private final Color COLOR_BORDE = Color.WHITE; // Bordes blancos para que se vean los contenedores
    private final Color COLOR_SELECCION = new Color(0, 100, 200); // Azul para selecciones

    private void iniciarComponentesDinamicos() {
        setTitle("Simulador SO - Proyecto 2 [DARK MODE]");
        setSize(1280, 720);
        setLayout(new BorderLayout(10, 10));
        
        // 1. FONDO DE LA VENTANA: NEGRO
        getContentPane().setBackground(COLOR_FONDO);

        // --- PANEL SUPERIOR (Usuario + Botones) ---
        JPanel panelTop = new JPanel(new FlowLayout(FlowLayout.LEFT));
        panelTop.setBackground(COLOR_FONDO);
        panelTop.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, COLOR_BORDE)); // Línea blanca abajo
        
        lblUsuario = new JLabel("Modo: USUARIO");
        lblUsuario.setFont(new Font("Consolas", Font.BOLD, 14)); // Fuente tipo terminal
        lblUsuario.setForeground(Color.CYAN); // Cyan destaca bien sobre negro
        
        // Botones superiores
        btnCambiarUsuario = crearBotonNegro("Cambiar Sesión");
        btnGuardar = crearBotonNegro("Guardar Estado");
        btnCargar = crearBotonNegro("Cargar Estado");
        
        btnCambiarUsuario.addActionListener(e -> accionCambiarUsuario());
        btnGuardar.addActionListener(e -> accionGuardar());
        btnCargar.addActionListener(e -> accionCargar());
        
        panelTop.add(lblUsuario);
        panelTop.add(Box.createHorizontalStrut(20));
        panelTop.add(btnCambiarUsuario);
        panelTop.add(Box.createHorizontalStrut(20));
        panelTop.add(btnGuardar);
        panelTop.add(Box.createHorizontalStrut(10));
        panelTop.add(btnCargar);
        
        add(panelTop, BorderLayout.NORTH);

        // --- PANEL IZQUIERDO (Explorador) ---
        treeModel = new DefaultTreeModel(new DefaultMutableTreeNode("Root"));
        treeDirectorios = new JTree(treeModel);
        estilizarArbol(treeDirectorios);
        
        JScrollPane scrollTree = new JScrollPane(treeDirectorios);
        scrollTree.setPreferredSize(new Dimension(250, 0));
        // Truco para quitar bordes blancos del scroll
        scrollTree.setBorder(BorderFactory.createLineBorder(COLOR_BORDE));
        scrollTree.getViewport().setBackground(COLOR_FONDO);
        
        JPanel panelIzq = crearPanelNegro("EXPLORADOR");
        panelIzq.add(scrollTree, BorderLayout.CENTER);
        add(panelIzq, BorderLayout.WEST);

        // --- PANEL CENTRAL (Mapa de Bits) ---
        panelDisco = new JPanel(new GridLayout(16, 16, 2, 2)); // Espacio de 2px entre bloques
        panelDisco.setBackground(COLOR_FONDO); // El fondo de la rejilla es negro
        
        JScrollPane scrollDisco = new JScrollPane(panelDisco);
        scrollDisco.setBorder(null);
        scrollDisco.getViewport().setBackground(COLOR_FONDO);
        
        JPanel panelCentro = crearPanelNegro("MAPA DE DISCO");
        panelCentro.add(scrollDisco, BorderLayout.CENTER);
        add(panelCentro, BorderLayout.CENTER);

        // --- PANEL INFERIOR (Tabla + Acciones) ---
        JPanel panelInf = new JPanel(new BorderLayout(10, 0));
        panelInf.setBackground(COLOR_FONDO);
        panelInf.setPreferredSize(new Dimension(0, 230));
        
        // Tabla de Procesos
        String[] col = {"PID", "Proceso", "Estado"};
        tableModelProcesos = new DefaultTableModel(col, 0);
        tablaProcesos = new JTable(tableModelProcesos);
        estilizarTabla(tablaProcesos);
        
        JScrollPane scrollTabla = new JScrollPane(tablaProcesos);
        scrollTabla.getViewport().setBackground(COLOR_FONDO);
        scrollTabla.setBorder(BorderFactory.createLineBorder(COLOR_BORDE));
        
        JPanel panelTabla = crearPanelNegro("COLA DE PROCESOS");
        panelTabla.add(scrollTabla, BorderLayout.CENTER);
        
        // Botones de Acción (Derecha)
        JPanel panelBtn = crearPanelNegro("CONTROLES");
        panelBtn.setPreferredSize(new Dimension(300, 0));
        
        JPanel gridBtn = new JPanel(new GridLayout(4, 1, 5, 15));
        gridBtn.setBackground(COLOR_FONDO);
        gridBtn.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JButton btnCrear = crearBotonNegro("Crear Archivo");
        JButton btnCarpeta = crearBotonNegro("Crear Carpeta");
        JButton btnEliminar = crearBotonNegro("Eliminar");
        
        lblEstadoDisco = new JLabel("Cargando...");
        lblEstadoDisco.setForeground(COLOR_TEXTO);
        lblEstadoDisco.setHorizontalAlignment(SwingConstants.CENTER);
        lblEstadoDisco.setFont(new Font("Consolas", Font.BOLD, 14));
        
        btnCrear.addActionListener(e -> accionCrearArchivo());
        btnCarpeta.addActionListener(e -> accionCrearCarpeta());
        btnEliminar.addActionListener(e -> accionEliminarArchivo());
        
        gridBtn.add(lblEstadoDisco);
        gridBtn.add(btnCrear);
        gridBtn.add(btnCarpeta);
        gridBtn.add(btnEliminar);
        
        panelBtn.add(gridBtn, BorderLayout.CENTER);
        
        panelInf.add(panelTabla, BorderLayout.CENTER);
        panelInf.add(panelBtn, BorderLayout.EAST);
        
        add(panelInf, BorderLayout.SOUTH);
        
        // Actualizar textos iniciales
        actualizarInfoUsuario();
    }

    // --- MÉTODOS DE ESTILO FORZADO (FONDO NEGRO / LETRA BLANCA) ---

    private JPanel crearPanelNegro(String titulo) {
        JPanel p = new JPanel(new BorderLayout());
        p.setBackground(COLOR_FONDO);
        // Borde blanco con título blanco
        p.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createLineBorder(COLOR_BORDE),
                titulo,
                0, 0,
                new Font("Consolas", Font.BOLD, 12),
                COLOR_TEXTO
        ));
        return p;
    }
    
    private JButton crearBotonNegro(String txt) {
        JButton b = new JButton(txt);
        
        // Forzamos colores
        b.setBackground(Color.BLACK); 
        b.setForeground(Color.WHITE);
        
        // Fuente tipo terminal
        b.setFont(new Font("Consolas", Font.BOLD, 13));
        
        // Borde blanco simple
        b.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(Color.WHITE, 1),
                BorderFactory.createEmptyBorder(8, 15, 8, 15)
        ));
        
        // Quitar efectos 3D que suelen ponerlo gris/blanco
        b.setFocusPainted(false);
        b.setContentAreaFilled(false); // Clave para que se vea negro el fondo del frame
        b.setOpaque(true); // Necesario en algunos L&F
        
        // Efecto Hover simple
        b.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                b.setBackground(new Color(50, 50, 50)); // Gris oscuro al pasar mouse
                b.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                b.setBackground(Color.BLACK); // Volver a negro
            }
        });
        
        return b;
    }
    
    private void estilizarArbol(JTree t) {
        t.setBackground(COLOR_FONDO);
        t.setForeground(COLOR_TEXTO);
        
        // Renderizador para obligar texto blanco en los nodos
        t.setCellRenderer(new javax.swing.tree.DefaultTreeCellRenderer() {
            @Override
            public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean exp, boolean leaf, int row, boolean hasFocus) {
                super.getTreeCellRendererComponent(tree, value, sel, exp, leaf, row, hasFocus);
                
                // Fondo
                if (sel) {
                    setBackgroundNonSelectionColor(COLOR_SELECCION);
                    setBackgroundSelectionColor(COLOR_SELECCION);
                } else {
                    setBackgroundNonSelectionColor(COLOR_FONDO);
                    setBackgroundSelectionColor(COLOR_FONDO);
                }
                
                // Texto
                setTextNonSelectionColor(COLOR_TEXTO);
                setTextSelectionColor(COLOR_TEXTO);
                
                return this;
            }
        });
    }
    
    private void estilizarTabla(JTable t) {
        t.setBackground(COLOR_FONDO);
        t.setForeground(COLOR_TEXTO);
        t.setGridColor(Color.GRAY);
        t.setRowHeight(25);
        t.setFont(new Font("Consolas", Font.PLAIN, 12));
        t.setSelectionBackground(COLOR_SELECCION);
        t.setSelectionForeground(Color.WHITE);
        
        // Encabezado Negro con letras Blancas
        javax.swing.table.JTableHeader header = t.getTableHeader();
        header.setBackground(new Color(40, 40, 40)); // Ligeramente gris para distinguir
        header.setForeground(Color.BLACK);
        header.setFont(new Font("Consolas", Font.BOLD, 13));
        header.setBorder(BorderFactory.createLineBorder(Color.BLACK));
    }
    // --- generated code --             
}
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

